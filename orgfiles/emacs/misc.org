#+TAGS: tech
** 設定ファイルを分割する方法

最も簡単な方法は load 関数を使って下のように読み込む。拡張子は省略しても良い。
ちょっと作ってみた関数とかは適当な名前をつけて隔離しておき下のようにして読み込めばいい。

#+begin_src lisp
(load "~/my-lisp/hogehoge.el")
#+end_src

より高機能な方法として require を使う方法がある。

#+begin_src
(require hoge-feature)
#+end_src

require の引数には feature と呼ばれるものを与える。
feature とは読み込もうとしているパッケージの名前で、パスではない。
feature に与えられる名前を持つには (provide) によりパッケージ名を定めなければならない。
自分で feature を作るには次のようなファイルを作る。

#+begin_src lisp
(provide 'hoge-feature)
(message "hoge-feature is loaded")
#+end_src

この feature はメッセージを出力するだけの feature である。
このファイルを ~/my-lisp/hoge-feature.el として保存してみよう。
最後に下記のプログラムを実行すれば ~/my-lisp/hoge-feature.el が読み込まれる。

#+begin_src lisp
(add-to-list 'load-path "~/my-lisp/")
(require hoge-feature)
#+end_src

変数 load-path は feature の探索範囲を示すリストで、このリストに ~/my-lisp/ を加えることでそこにあるファイルを見つけることができる。

require を使えば2重に読み込んでしまうことを避けられるので、
いろいろなパッケージから参照されているようなパッケージは require を使って読み込むべきである。
ただし、自分だけの設定ファイルなどはよそから参照されることはないので、普段遣いは load で十分だろう。

** ラムダ（匿名関数）

フックを使って emacs をカスタマイズするとき、引数に関数あたえなければならない。
しかしわざわざ関数に名前をつけるのが面倒なときには、ラムダを使って名前のない関数を作ることができる。

#+begin_src lisp
(lambda () (message "hello"))
#+end_src

ラムダ関数の第一引数は引数のリストで、それ以降が本体である。
ラムダを評価するには関数 funcall を使う。

#+begin_src lisp
(setq my-lambda (lambda () (message "hello")))
(funcall my-lambda)
#+end_src

引数がある場合は下のようにする。

#+begin_src
(setq my-lambda (lambda (a b) (message (concat a b))))
(funcall my-lambda "hoge" "fuga")
#+end_src

** ローカル変数(let)
特殊形式 (let VARLIST BODY...) で表現する。

- VARLIST は1つ以上の (変数名 値) からなるリスト
- BODY は1つ以上の式

もっともかんたんな使い方は下のようになる。

#+begin_src lisp
(let ((a "hello")) (message a))
#+end_src

変数名のリストをあたえてもよい。
その場合は nil がセットされるので、あとから値をセットする。

#+begin_src lisp
(let (a b)
  (setq a "hello")
  (setq b "goodbye")
  (message (concat a b)))
#+end_src

let は BODY で最後に評価した式の値を返す。

アスタリスク付きの let* も存在する。
let* は変数の初期化を VARLIST で列挙された順に一つずつ行う。
下のプログラムは let* だけが実行でき let は実行できない。

#+begin_src lisp
(let* ((a "hello") (z a)) (message z))
#+end_src

** プロパタイズ(propertize)

(propertize STRING &rest PROPERTIES)

- STRING はコピー対象の文字列
- PROPERTIES は PROPERTY VALUE のペア列

評価結果はプロパティを持つオブジェクトになる。
関数 get-text-property を使ってオブジェクトのプロパティを取り出すことができる。

#+begin_src lisp
(let ((x (propertize "john" :age 20 :height 170)))
  (print (get-text-property 0 :age x))
  (print (get-text-property 0 :height x)))
#+end_src

プロパティにラムダをセットすることもできるようだ。

** フォントフェイス

フェイスは文字を装飾するためのオブジェクト。代表的な属性としては下記のものがある。

- font(フォント)
- height(高さ)
- weight(太さ)
- slant(傾き)
- foreground(前景)
- background(背景)
- underline(アンダーライン)
- overline(オーバーライン)
- inherit(継承元)

定義済みのフェイス一覧を見るには、list-faces-display を実行する。特定のフェイスの属性を確認したい場合は describe-face を実行する。

ほとんどのモードはマイナーモードとして font-lock-mode を伴っており自動的に font-lock-mode が有効になる。すると、そのバッファのテキストには特定のフェイスが割り当てられるようになる。

https://ayatakesi.github.io/emacs/27.1/emacs-ja.html#Faces

** フック(hook)

フックは、関数もしくは関数のリストを持っている変数のこと。他の言語で言うコールバックのようなもの。たとえばフック ~find-file-not-found-hooks~ は、ファイルを探しても見つからなかったときに呼び出される関数（のリスト）である。フックは引数なしで呼び出される。

変数名が ~-hook(s)~ で終わらないフックも存在する。それはアブノーマルフックと呼ばれる。通常のフックは引数を取らず、戻り値も利用しないが、アブノーマルフックは引数を取ったり、戻り値を利用したりする。

フックに関数を追加するときは `add-hook` を使うべきである。add-hook は、リスト操作の関数よりも高級であり、重複している場合追加しない、といった機能を備えている。

#+begin_src lisp
(add-hook 'ruby-mode-hook 'lsp-mode) ; ruby-mode のフックに lsp-mode を追加する
#+end_src

add-hook は通常は2つの引数で十分だが、第3引数, 第4引数を与えることもできる。第3引数はフックの挿入位置のフラグ。省略した場合は先頭に追加される。先頭に追加された場合は他よりも先に呼び出される（が基本的には順序依存させないようにするべき）フラグを省略せず t を与えた場合はフックリストの末尾に追加される。第4引数はローカルフックのフラグとなっていて、これが t の場合はバッファローカルなフックとなる。

フックがちゃんと動くかどうか確かめたいときは `run-hook` を使う。たとえば下記のようにすると `org-mode-hook` フックに登録された関数が呼び出される。

#+begin_src lisp
(run-hooks 'org-mode-hook)
#+end_src
** 変数宣言

変数宣言には defconst, defvar がある。これらは特殊形式で下のように振る舞う。

- defconst は常に変数を初期化する。
- defvar は変数が未設定のときだけ初期化する。

defvar がこうなっているのは、ユーザーが事前に setq でカスタムした場合にそれを反映されるため。
defvar, defconst はコメントを書いておくと setq と違って describe-variables で説明を出してくれる。

** コンスセル

コンスセルは2つの任意要素 CAR, CDR の対である。
コンスセルを作るには関数 cons を利用する。

(cons "hello" 2)

上記の関数を評価した値は、 CAR が "hello" であり CDR が 2 のコンスセルである。Emacs の実行環境で試した場合は ("hello" . 2) と表示される。コンスセルは、その要素としてコンスセルを持つことができる。

(cons "boo" (cons "hello" (cons "goodbye" nil)))

上記の関数を評価した値は下記のような構造を持ったコンスセルとなる。

- CAR "boo"
- CDR
  - CAR "hello"
  - CDR
    - CAR "goodbye"
    - CDR nil

これは一般に連結リスト(linked list)と呼ばれるデータ構造をなす。最後の nil はリストが終わりであることを表すマーカで、終端記号と呼ばれる。Emacs の実行環境では ("boo" "hello" "goodbye") と表示される。

つまり、これまでリストと呼んでいたものはコンスセルだとも言える。たとえばリスト ("a" "b" "c") に対してその CAR, CDR を計算すると、それがコンスセルであることがわかる。

(car '("a" "b" "c")) ;; a を返す
(cdr '("a" "b" "c")) ;; ("b" "c") を返す

** 型を調べる

変数 x があるとき (type-of x) でその型を調べることができる。

** 関数へのパッチ(advice-add)

かつては defadvice という関数が使われていたが今では advice-add を使うのが推奨されているようだ。

https://misaki-blog.com/191026-emacs-advice-add/ ここに例がある。

(defun my-find-file (old-func &rest args)
  (print args)
  (apply old-func args))

(advice-add #'find-file :around #'my-find-file)
* grep について

ripgrep.el をインストールして ripgrep-regex を使う。

emacs では ripgrep などで検索した結果をファイルに保存することができる。
保存したファイルは特に拡張子などは必要なく、emacs で開き直せばハイライトやリンクを再現できる。
おそらく、検索結果にgrepモードや、検索のルートディレクトリ、検索コマンドなどのメタ情報が含まれているため。

保存した検索結果を開くと g で再検索したり、wgrep の機能を利用したりすることもできる。
M-x read-only-mode を実行して読み込み専用モードを解除すれば編集して必要な結果だけ切り取って保存したり、複数の検索結果をマージすることもできる。
（ただその場合は再検索すると壊れるが）

OR検索したい場合は正規表現で検索する。たとえば (BookStore|book_store) のようにすると BookStore と book_store の両方を検索できる。
検索コマンドによっては --fixed-strings または -F オプションが自動的に付与されてしまって、正規表現で検索できないこともある。
拡張した検索コマンドを用意しておくと楽かもしれない。

#+begin_src lisp
(defun ripgrep-regexp-with-arguments (regexp directory args)
  (interactive
    (list (read-from-minibuffer "Ripgrep search for: ")
          (read-directory-name "Directory: ")
          (read-from-minibuffer "optional arguments: ")))
    (ripgrep-regexp regexp directory (list args)))
#+end_src
